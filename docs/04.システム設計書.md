# AI漫画生成サービス システム設計書

**文書管理情報**
- 文書ID: SYS-DOC-001
- 作成日: 2025-08-28
- 版数: 3.0
- 承認者: 根岸祐樹
- 関連文書: REQ-DOC-001（要件定義書）

## 目次

- [1. システム概要](#1-システム概要)
  - [1.1 設計方針](#11-設計方針)
  - [1.2 アーキテクチャ概要](#12-アーキテクチャ概要)
- [2. 実装詳細仕様](#2-実装詳細仕様)
  - [2.1 7フェーズエージェント実装](#21-7フェーズエージェント実装)
  - [2.2 コアサービス実装](#22-コアサービス実装)
  - [2.3 パイプライン制御・並列処理](#23-パイプライン制御並列処理)
  - [2.4 データスキーマ・アーキテクチャ](#24-データスキーマアーキテクチャ)
- [3. モノリシックサービス設計](#3-モノリシックサービス設計)
  - [3.1 サービス構成](#31-サービス構成)
  - [3.2 モジュール間連携](#32-モジュール間連携)
  - [3.3 データフロー](#33-データフロー)
- [4. インフラストラクチャ設計](#4-インフラストラクチャ設計)
  - [4.1 Cloud Run構成](#41-cloud-run構成)
  - [4.2 ストレージ設計](#42-ストレージ設計)
  - [4.3 Redis単一インスタンス設計](#43-redis単一インスタンス設計)
- [5. 外部API統合設計](#5-外部api統合設計)
  - [5.1 Google AI API接続](#51-google-ai-api接続)
  - [5.2 レート制限管理](#52-レート制限管理)
- [6. 信頼性設計](#6-信頼性設計)
  - [6.1 エラーハンドリング](#61-エラーハンドリング)
  - [6.2 リトライ戦略](#62-リトライ戦略)
- [7. セキュリティ設計](#7-セキュリティ設計)
- [8. パフォーマンス設計](#8-パフォーマンス設計)

---

## 1. システム概要

### 1.1 設計方針

本システムは以下の設計原則に基づいて構築される：

| 原則 | 内容 |
|------|------|
| モノリシック設計 | 7フェーズを単一サービス内のモジュールとして実装（HITL対応） |
| サーバーレス優先 | Google Cloud Runによる運用負荷削減 |
| インメモリ処理 | メモリ内データ受け渡し+段階的フィードバック処理 |
| 簡素化設計 | Redis単一インスタンス、コスト効率重視 |
| 自動復旧 | 3回までの自動リトライ機構 |
| 人間参加型 | 各フェーズでの自然言語フィードバック統合 |

### 1.2 アーキテクチャ概要

```mermaid
graph TB
    subgraph "Client Layer"
        A[Web Application]
        B[Mobile App]
    end
    
    subgraph "API Gateway"
        C[Cloud Endpoints]
    end
    
    subgraph "Monolithic Service on Cloud Run"
        D[Manga Generation Service]
        subgraph "7-Phase HITL Processing"
            D1[Phase1: コンセプト・世界観分析]
            D2[Phase2: キャラクター設定]
            D3[Phase3: プロット・ストーリー構成]
            D4[Phase4: ネーム生成]
            D5[Phase5: シーン画像生成]
            D6[Phase6: セリフ配置]
            D7[Phase7: 最終統合・品質調整]
            F[Feedback Parser & Modifier]
        end
    end
    
    subgraph "Data Layer"
        M[Redis Single Instance]
        N[Cloud Storage + CDN]
        O[PostgreSQL]
    end
    
    subgraph "External APIs"
        P[Google Gemini Pro]
        Q[Google Imagen 4]
    end
    
    A --> C
    B --> C
    C --> D
    
    D --> M
    D --> N
    D --> O
    
    D --> P
    D --> Q
    
    D1 --> F
    F --> D2
    D2 --> F
    F --> D3
    D3 --> F
    F --> D4
    D4 --> F
    F --> D5
    D5 --> F
    F --> D6
    D6 --> F
    F --> D7
```

---

## 2. 実装詳細仕様

### 2.1 7フェーズエージェント実装

#### システムコンポーネント構成

7フェーズエージェントシステムは以下の設計原則に基づいて構築される：

#### Phase 1: コンセプト・世界観分析エージェント
- **責任**: 入力テキストからストーリーのコンセプト、テーマ、世界観を抽出・定義
- **設計判断**: テキスト分析の基盤として最初に実行し、後続フェーズの基準を確立
- **出力**: コンセプト定義、メタデータ構造

#### Phase 2: キャラクター設計エージェント  
- **責任**: Phase1の世界観に基づいてキャラクター設定とビジュアル方向性を決定
- **設計判断**: アーキタイプ分析によりキャラクターの一貫性を保証
- **出力**: キャラクター設定、性格特性、ビジュアル指針

#### Phase 3: プロット・ストーリー構成エージェント
- **責任**: ストーリー構成の設計と最適化されたページ配分の決定
- **設計判断**: 3幕構成による構造化されたナラティブ管理
- **出力**: ストーリー構成、感情アーク、ページ配分

#### Phase 4: ネーム生成エージェント【重要】
- **責任**: パネルレイアウト設計、カメラアングル選択、構図の最適化
- **設計判断**: 視覚的表現力を最大化するレイアウト設計システム
- **特徴**: 多様なカメラアングル、構図理論の適用、視覚フロー最適化

#### Phase 5: シーン画像生成エージェント
- **責任**: 高品質な画像生成と視覚的一貫性の管理
- **設計判断**: 並列処理による効率化とキャッシュ機構による最適化
- **特徴**: 並列ワーカー設計、リトライ機構、キャッシュ最適化

#### Phase 6: セリフ配置エージェント
- **責任**: セリフ・エフェクトの最適配置と可読性の確保
- **設計判断**: 多様なセリフタイプへの対応とレイアウト連携
- **特徴**: セリフタイプ分類システム、配置アルゴリズム、テキスト処理

#### Phase 7: 最終統合・品質調整エージェント
- **責任**: 全フェーズの統合、品質評価、出力フォーマット生成
- **設計判断**: 多面的品質評価による包括的品質管理
- **特徴**: 多層品質評価、複数出力フォーマット、アクセシビリティ対応

### 2.2 コアサービス設計

#### 統合AI処理サービス
- **役割**: 7フェーズパイプライン全体の統括管理
- **設計原則**: 単一責任によるパイプライン制御と状態管理
- **機能領域**:
  - パイプライン実行制御・進捗管理
  - HITLフィードバック統合処理
  - 品質ゲート評価・制御
  - リアルタイムレスポンス配信

#### キャッシュ管理サービス
- **役割**: 多層キャッシュアーキテクチャによる性能最適化
- **設計原則**: 階層化キャッシュによる効率的なデータアクセス
- **アーキテクチャ**:
  - L1層: メモリキャッシュ（高速アクセス）
  - L2層: Redis（セッション管理）
  - L3層: データベース（永続化）

#### リアルタイム通信サービス
- **役割**: HITL機能のためのリアルタイム双方向通信
- **設計原則**: WebSocketベースの低遅延通信アーキテクチャ
- **機能領域**:
  - 双方向メッセージング・進捗配信
  - フィードバック収集・処理
  - セッション状態管理・同期

### 2.3 パイプライン制御・並列処理

#### 並列処理システム
- **Phase 5並列画像生成**: 5並列ワーカーによる高速処理
- **非同期処理**: I/O効率化による処理時間短縮
- **セマフォ制御**: 同時実行数制御による安定性確保

#### キャッシュ戦略
```python
キャッシュTTL設定:
- phase_result: 3600秒 (1時間)
- image: 7200秒 (2時間)  
- preview: 1800秒 (30分)
- session: 300秒 (5分)
- ai_response: 600秒 (10分)
```

#### 品質ゲート制御
```python
品質閾値:
- minimum_acceptable: 0.6
- target_quality: 0.8
- excellence_threshold: 0.9
```

### 2.4 データスキーマ・アーキテクチャ

#### 実装済みAPIエンドポイント
```python
# メインエンドポイント
POST   /api/v1/manga/generate              # 生成開始（SSEストリーミング）
GET    /api/v1/manga/sessions              # セッション一覧
GET    /api/v1/manga/sessions/{id}         # セッション詳細
GET    /api/v1/manga/sessions/{id}/status  # ステータス取得
POST   /api/v1/manga/sessions/{id}/cancel  # キャンセル

# HITLエンドポイント
WS     /ws/session/{session_id}            # WebSocket接続
POST   /api/v1/manga/sessions/{id}/hitl-feedback  # フィードバック送信
```

#### コアデータベースモデル
- **MangaSession**: メイン生成セッション
- **PhaseResult**: 各フェーズの結果
- **PreviewVersion**: バージョン管理
- **UserFeedback**: HITLフィードバック
- **GeneratedImage**: 画像メタデータ

#### 環境設定
```env
# Database
DATABASE_URL=postgresql+asyncpg://user:pass@localhost/manga_db

# Redis
REDIS_URL=redis://localhost:6379/0

# AI APIs
GEMINI_API_KEY=your_key
IMAGEN_API_KEY=your_key

# Phase Timeouts
PHASE_TIMEOUTS={"1":12,"2":18,"3":15,"4":20,"5":25,"6":4,"7":3}
```

#### ヘルスチェック・監視
- `/health/live` - Liveness probe
- `/health/ready` - Readiness probe  
- `/health/startup` - Startup probe

#### パフォーマンスメトリクス
- Phase実行時間
- 品質スコア（フェーズ別）
- キャッシュヒット率
- WebSocket接続数

#### 実装ステータス
- ✅ 全7フェーズエージェント実装完了
- ✅ IntegratedAIService オーケストレーション
- ✅ 3層キャッシュシステム
- ✅ WebSocket HITL通信
- ✅ Phase 5並列処理
- ✅ 品質ゲートシステム
- ✅ 包括的エラーハンドリング
- ✅ プロダクション対応アーキテクチャ

**総合実装完了率: 100%**

---

## 3. モノリシックサービス設計

### 3.1 サービス構成

#### 2.1.1 統合サービス構成

**サービスID**: SVC-MANGA-GENERATION  
**責務**: 漫画生成の全フェーズ処理  
**実装言語**: Python 3.11  
**コンテナサイズ**: 8 vCPU, 32GB RAM  

**入力**:
```json
{
  "request_id": "string",
  "text": "string",
  "ai_auto_settings": true,
  "feedback_mode": {
    "enabled": true,
    "timeout_seconds": 1800
  }
}
```

**出力**:
```json
{
  "request_id": "string",
  "manga_result": {
    "plot_structure": {},
    "characters": [],
    "scenes": [],
    "final_manga_url": "string"
  },
  "phase_results": [
    {
      "phase": 1,
      "content": {},
      "preview_url": "string",
      "feedback_applied": []
    }
  ],
  "processing_time": "number"
}
```

**処理時間制限**: 600秒（10分）

#### 2.1.2 処理Agent構成

| Agent名 | 責務 | 処理時間目安 | フィードバック対象 |
|------------|------|------------|------------------|
| Phase1: コンセプト・世界観分析Agent | コンセプト・テーマ・ジャンル・ターゲット読者層・世界観決定 | 12秒 | コンセプト・ジャンル・世界観調整 |
| Phase2: キャラクター設定・簡易ビジュアル生成Agent | キャラクター詳細設定・簡易ビジュアル生成（1-2枚の参考画像） | 18秒 | キャラ設定・ビジュアル調整 |
| Phase3: プロット・ストーリー構成Agent | 詳細なプロット・ストーリー構成作成（3幕構成） | 15秒 | プロット・シーン構成調整 |
| Phase4: ネーム生成Agent | コマ割り設計・シーン詳細指示・カメラアングル（Phase1の世界観情報を活用） | 20秒 | コマ割り・構図・演出調整 |
| Phase5: シーン画像生成Agent | コマごとのシーン画像並列生成（Imagen 4） | 25秒 | 画像品質・スタイル調整 |
| Phase6: セリフ配置Agent | 吹き出し・セリフ・効果音の配置最適化 | 4秒 | セリフ・効果音配置調整 |
| Phase7: 最終統合・品質調整Agent | 最終品質チェック・統合処理・出力 | 3秒 | 最終調整・フォーマット選択 |

**Agent間データ受け渡し**:
```python
class MangaGenerationService:
    def __init__(self):
        # Core AI Agents
        self.agents = {
            'concept_analysis': ConceptAnalysisAgent(),  # Phase 1: コンセプト・世界観分析
            'character_visual': CharacterVisualAgent(),  # Phase 2: キャラクター設定・簡易ビジュアル生成
            'plot_structure': PlotStructureAgent(),  # Phase 3: プロット・ストーリー構成
            'name_generation': NameGenerationAgent(),  # Phase 4: ネーム生成
            'scene_generation': SceneGenerationAgent(),  # Phase 5: シーン画像生成
            'text_placement': TextPlacementAgent(),  # Phase 6: セリフ配置
            'final_integration': FinalIntegrationAgent()  # Phase 7: 最終統合・品質調整
        }
        
        # Preview System Integration
        self.preview_service = PreviewService()
        self.version_manager = PreviewVersionManager()
        self.quality_adapter = AdaptiveQualityManager()
        self.cdn_cache = CDNOptimizedCacheStrategy()
        self.websocket_manager = WebSocketManager()
        self.interaction_processor = InteractiveChangeProcessor()
    
    async def process_request(self, request):
        # インメモリでデータを順次処理
        data = request
        user_quality_setting = await self.quality_adapter.get_user_settings(request.user_id)
        
        for phase, (agent_name, agent) in enumerate(self.agents.items(), 1):
            # Phase processing
            data = await agent.process(data)
            
            # Generate phase-specific preview
            preview_data = await self.preview_service.generate_preview(
                phase=phase,
                data=data,
                quality_level=user_quality_setting.preferred_quality
            )
            
            # Create version branch
            version_id = self.version_manager.create_branch(
                parent_id=getattr(request, 'current_version_id', None),
                data=preview_data,
                description=f"Phase {phase} completion"
            )
            
            # Cache preview to CDN  
            preview_url = await self.cdn_cache.cache_preview_data(phase, preview_data)
            
            # WebSocket notification
            await self.websocket_manager.send_phase_complete(
                request_id=request.id,
                phase=phase,
                preview_url=preview_url,
                version_id=version_id
            )
            
            # Wait for user feedback (30 seconds timeout)
            feedback = await self.wait_for_feedback(request.id, phase, timeout=30)
            if feedback:
                # Apply user feedback
                modified_data = await self.interaction_processor.apply_feedback(
                    data, feedback, phase
                )
                data = modified_data
                
                # Create feedback branch
                feedback_version = self.version_manager.create_branch(
                    parent_id=version_id,
                    data=modified_data,
                    description=f"Phase {phase} user feedback applied"
                )
            
            # Database checkpoint save
            await self.save_checkpoint(request.id, agent_name, data)
            
        return data
```

### 3.2 Agent間連携

#### 2.2.1 データパイプライン設計

```python
@dataclass
class ProcessingContext:
    request_id: str
    current_phase: int
    data: Dict[str, Any]
    metadata: Dict[str, Any]
    processing_times: List[float]
    feedback_history: List[Dict[str, Any]]  # HITL フィードバック履歴
    preview_versions: List[str]  # プレビューバージョン管理
    
class DataPipeline:
    def __init__(self):
        self.feedback_handler = HITLFeedbackHandler()
        self.preview_generator = PreviewGenerator()
        self.websocket_manager = WebSocketManager()
    
    async def execute(self, context: ProcessingContext):
        for phase in range(1, 8):  # Phase 1-7
            start_time = time.time()
            context.current_phase = phase
            
            # モジュール実行
            module = self.get_module(phase)
            result = await module.process(context.data)
            
            # プレビュー生成
            preview = await self.preview_generator.generate(phase, result)
            
            # WebSocket経由でプレビュー通知
            await self.websocket_manager.send_preview(
                context.request_id, phase, preview
            )
            
            # フィードバック待機（最大30分）
            feedback = await self.feedback_handler.wait_for_feedback(
                context.request_id, phase, timeout=1800
            )
            
            if feedback:
                # フィードバックを適用して再処理
                result = await module.apply_feedback(result, feedback)
                context.feedback_history.append({
                    'phase': phase,
                    'feedback': feedback,
                    'timestamp': time.time()
                })
            
            context.data = result
            
            # 処理時間記録
            context.processing_times.append(time.time() - start_time)
            
            # チェックポイント保存（非同期）
            asyncio.create_task(self.save_checkpoint(context))
        
        return context
```

#### 2.2.2 エラー伝播とリカバリ

```python
class ModuleErrorHandler:
    def __init__(self):
        self.retry_configs = {
            'phase1_concept': {'max_retries': 3, 'delay': 1},
            'phase2_character': {'max_retries': 3, 'delay': 2},
            'phase3_plot': {'max_retries': 3, 'delay': 1},
            'phase4_name': {'max_retries': 3, 'delay': 2},
            'phase5_scene': {'max_retries': 3, 'delay': 5},
            'phase6_dialog': {'max_retries': 3, 'delay': 1},
            'phase7_final': {'max_retries': 3, 'delay': 2}
        }
    
    async def handle_module_error(self, module_name, error, context):
        config = self.retry_configs[module_name]
        for attempt in range(config['max_retries']):
            try:
                await asyncio.sleep(config['delay'] * (2 ** attempt))
                return await self.retry_module(module_name, context)
            except Exception as e:
                if attempt == config['max_retries'] - 1:
                    raise ModuleProcessingError(f"Module {module_name} failed after {config['max_retries']} attempts")
```

### 3.3 刷新された7フェーズ詳細設計

#### 2.3.1 Phase 4: ネーム生成Agent詳細設計（最重要工程）

```python
class NameGenerationModule:
    """
    漫画制作における「ネーム」（コマ割り・演出・セリフ配置の設計図）を生成
    """
    def __init__(self):
        self.layout_analyzer = PanelLayoutAnalyzer()
        self.scene_director = SceneDirector()
        self.dialog_designer = DialogDesigner()
        
    async def process(self, input_data: dict) -> dict:
        plot_data = input_data['plot']  # Phase 1のプロット結果を使用
        characters = input_data['basic_characters']  # プロットで定義された基本キャラ
        
        # 1. コマ割り設計
        panel_layouts = await self.design_panel_layouts(plot_data)
        
        # 2. シーン演出詳細指示生成
        scene_directions = await self.generate_scene_directions(plot_data, characters)
        
        # 3. セリフ配置設計
        dialog_layouts = await self.design_dialog_layouts(plot_data, panel_layouts)
        
        return {
            'panel_layouts': panel_layouts,
            'scene_directions': scene_directions,
            'dialog_layouts': dialog_layouts,
            'complete_name': self.integrate_name_components(panel_layouts, scene_directions, dialog_layouts)
        }
    
    async def design_panel_layouts(self, plot_data: dict) -> List[PanelLayout]:
        """
        コマ割り設計：
        - ページごとの最適なコマ数決定
        - 重要シーンの大ゴマ配置
        - 視線誘導を考慮したレイアウト
        """
        layouts = []
        for page_data in plot_data['pages']:
            panel_count = self.calculate_optimal_panel_count(page_data)
            importance_scores = self.analyze_scene_importance(page_data)
            
            layout = PanelLayout(
                page_number=page_data['page_number'],
                panel_count=panel_count,
                panel_sizes=self.determine_panel_sizes(importance_scores),
                flow_direction=self.determine_reading_flow(page_data),
                emphasis_panels=self.identify_emphasis_panels(importance_scores)
            )
            layouts.append(layout)
        
        return layouts
    
    async def generate_scene_directions(self, plot_data: dict, characters: List) -> List[SceneDirection]:
        """
        シーン生成詳細指示生成：
        - キャラクター配置（前景/中景/後景）
        - カメラアングル（俯瞰、アオリ、正面、バストショット等）
        - 表情・ポーズの具体的指示
        - 背景要素の詳細
        - 効果線・演出指示
        """
        directions = []
        for scene in plot_data['scenes']:
            direction = SceneDirection(
                scene_id=scene['id'],
                character_positioning=await self.determine_character_positioning(scene, characters),
                camera_angle=await self.select_camera_angle(scene),
                character_expressions=await self.specify_expressions(scene, characters),
                character_poses=await self.specify_poses(scene, characters),
                background_elements=await self.design_background_elements(scene),
                effect_lines=await self.design_effect_lines(scene),
                lighting_mood=await self.determine_lighting_mood(scene)
            )
            directions.append(direction)
        
        return directions
```

#### 2.3.2 Phase 5: シーン画像並列生成Agent設計

```python
class ParallelImageGenerationModule:
    def __init__(self):
        self.max_parallel = 5  # 最大並列数
        self.imagen_client = ImagenClient()
        self.cache_manager = SceneCacheManager()
        self.progress_tracker = ProgressTracker()
    
    async def process(self, scenes: List[Scene]) -> List[GeneratedImage]:
        # 1. シーン類似度解析とキャッシュ検索
        cache_results = await self.cache_manager.check_similarities(scenes)
        
        # 2. 生成が必要なシーンを特定
        scenes_to_generate = self.filter_uncached_scenes(scenes, cache_results)
        
        # 3. 並列バッチ処理
        batches = self.create_batches(scenes_to_generate, self.max_parallel)
        generated_images = []
        
        for batch in batches:
            batch_results = await self.process_batch_parallel(batch)
            generated_images.extend(batch_results)
            
            # プログレス更新
            await self.progress_tracker.update(len(generated_images), len(scenes))
        
        # 4. キャッシュされた画像と統合
        final_results = self.merge_with_cache(generated_images, cache_results)
        
        return final_results
    
    async def process_batch_parallel(self, batch: List[Scene]) -> List[GeneratedImage]:
        tasks = [
            self.generate_single_image(scene) 
            for scene in batch
        ]
        return await asyncio.gather(*tasks, return_exceptions=True)
    
    async def generate_single_image(self, scene: Scene) -> GeneratedImage:
        try:
            # プロンプト生成
            prompt = self.create_prompt(scene)
            
            # Imagen API呼び出し
            image_data = await self.imagen_client.generate(prompt)
            
            # 結果処理
            generated_image = GeneratedImage(
                scene_id=scene.id,
                image_data=image_data,
                prompt=prompt,
                timestamp=datetime.now()
            )
            
            # キャッシュ保存
            await self.cache_manager.store(scene, generated_image)
            
            return generated_image
            
        except Exception as e:
            # エラーハンドリング：部分回復
            return self.create_fallback_image(scene, e)
```

#### 2.3.2 シーン類似度キャッシング

```python
class SceneCacheManager:
    def __init__(self):
        self.similarity_threshold = 0.85
        self.cache_ttl = 86400  # 24時間
    
    async def check_similarities(self, scenes: List[Scene]) -> Dict[str, CacheResult]:
        results = {}
        
        for scene in scenes:
            # シーン特徴量抽出
            features = self.extract_features(scene)
            
            # 類似シーン検索
            similar_scenes = await self.find_similar_scenes(features)
            
            if similar_scenes:
                # 最も類似度が高いものを使用
                best_match = max(similar_scenes, key=lambda x: x.similarity)
                if best_match.similarity >= self.similarity_threshold:
                    results[scene.id] = CacheResult(
                        cached_image=best_match.image,
                        similarity_score=best_match.similarity
                    )
        
        return results
    
    def extract_features(self, scene: Scene) -> SceneFeatures:
        return SceneFeatures(
            setting=scene.setting,
            characters=scene.characters,
            emotion=scene.emotion,
            camera_angle=scene.camera_angle,
            time_of_day=scene.time_of_day
        )
```

#### 2.3.3 リアルタイム進捗管理

```python
class ProgressTracker:
    def __init__(self):
        self.redis_client = redis.Redis()
    
    async def update(self, completed: int, total: int):
        progress_data = {
            'phase': 6,
            'completed': completed,
            'total': total,
            'percentage': (completed / total) * 100,
            'timestamp': datetime.now().isoformat()
        }
        
        # Redis経由でリアルタイム更新
        await self.redis_client.publish(
            f'progress:{self.request_id}',
            json.dumps(progress_data)
        )
        
        # WebSocket経由でフロントエンドに通知
        await self.websocket_manager.broadcast(
            f'image_progress_{self.request_id}',
            progress_data
        )
```

#### 2.3.4 エラー回復・フォールバック戦略

```python
class FallbackImageGenerator:
    async def create_fallback_image(self, scene: Scene, error: Exception) -> GeneratedImage:
        # 1. 簡易プロンプトで再試行
        simplified_prompt = self.create_simplified_prompt(scene)
        try:
            return await self.imagen_client.generate(simplified_prompt)
        except:
            # 2. プレースホルダー画像生成
            return self.create_placeholder_image(scene, str(error))
    
    def create_placeholder_image(self, scene: Scene, error_msg: str) -> GeneratedImage:
        # テキストベースのプレースホルダー生成
        placeholder = PlaceholderImage(
            text=f"Scene {scene.id}: {scene.description}",
            error_message=error_msg,
            size=(1024, 1024)
        )
        return GeneratedImage.from_placeholder(placeholder)
```

### 3.5 プレビューシステム統合設計

#### 2.5.1 プレビューサービス詳細実装

```python
class PreviewService:
    """
    フェーズ特化型プレビュー生成サービス
    """
    def __init__(self):
        self.phase_processors = {
            1: ConceptPreviewProcessor(),
            2: CharacterPreviewProcessor(), 
            3: PlotPreviewProcessor(),
            4: NamePreviewProcessor(),
            5: ScenePreviewProcessor(),
            6: TextPreviewProcessor(),
            7: FinalPreviewProcessor()
        }
        self.quality_renderer = QualityRenderer()
        
    async def generate_preview(self, phase: int, data: dict, quality_level: int) -> PreviewData:
        processor = self.phase_processors[phase]
        
        # Phase-specific data structure generation
        structured_data = await processor.structure_data(data)
        
        # Interactive elements definition
        interactive_elements = processor.define_interactions(structured_data)
        
        # Quality-adapted rendering
        rendered_preview = await self.quality_renderer.render(
            structured_data, quality_level
        )
        
        return PreviewData(
            phase=phase,
            version=self.generate_version_id(),
            timestamp=datetime.now(),
            data=structured_data,
            interactive_elements=interactive_elements,
            rendered_content=rendered_preview
        )

class AdaptiveQualityManager:
    """
    デバイス性能に応じた品質自動調整
    """
    async def determine_quality(self, user_id: str, device_info: dict) -> int:
        # Device capability calculation
        memory = device_info.get('memory_gb', 4)
        cores = device_info.get('cpu_cores', 2) 
        network = device_info.get('network_speed', 5000)
        
        capability_score = self.calculate_capability(memory, cores, network)
        
        # User preference consideration
        user_pref = await self.get_user_preference(user_id)
        
        # Final quality determination
        quality_level = min(
            5,
            max(1, int(capability_score * 5 * user_pref.quality_multiplier))
        )
        
        return quality_level

class WebSocketManager:
    """
    リアルタイム通知管理
    """
    def __init__(self):
        self.connections: Dict[str, List[WebSocket]] = {}
        
    async def send_phase_complete(self, request_id: str, phase: int, preview_url: str, version_id: str):
        message = {
            "type": "phase_complete",
            "phase": phase,
            "preview_url": preview_url,
            "version_id": version_id,
            "timestamp": datetime.now().isoformat()
        }
        
        await self.broadcast_to_request(request_id, message)
    
    async def send_preview_change(self, request_id: str, element_id: str, change_data: dict):
        message = {
            "type": "preview_change",
            "element_id": element_id,
            "change_data": change_data,
            "timestamp": datetime.now().isoformat()
        }
        
        await self.broadcast_to_request(request_id, message)

class InteractiveChangeProcessor:
    """
    インタラクティブ変更処理
    """
    async def apply_feedback(self, data: dict, feedback: dict, phase: int) -> dict:
        change_type = feedback.get('change_type')
        
        if change_type == 'text_edit':
            return await self.apply_text_change(data, feedback)
        elif change_type == 'selection':
            return await self.apply_selection_change(data, feedback)
        elif change_type == 'drag_drop':
            return await self.apply_position_change(data, feedback)
        elif change_type == 'style_adjust':
            return await self.apply_style_change(data, feedback)
        
        return data
    
    async def apply_text_change(self, data: dict, feedback: dict) -> dict:
        element_path = feedback['element_id'].split('.')
        new_value = feedback['change_data']['new_value']
        
        # Deep path navigation and update
        current = data
        for key in element_path[:-1]:
            current = current[key]
        current[element_path[-1]] = new_value
        
        return data

class PreviewVersionManager:
    """
    ブランチ型バージョン管理
    """
    def __init__(self):
        self.db_connector = DatabaseConnector()
        
    def create_branch(self, parent_id: str, data: PreviewData, description: str) -> str:
        version_id = self.generate_version_id()
        
        # Database record creation
        version_record = {
            'version_id': version_id,
            'parent_version_id': parent_id,
            'phase': data.phase,
            'version_data': data.to_json(),
            'change_description': description,
            'quality_level': data.quality_level,
            'quality_score': self.calculate_quality_score(data),
            'created_at': datetime.now()
        }
        
        self.db_connector.insert('preview_versions', version_record)
        
        return version_id
    
    async def get_version_history(self, request_id: str, phase: int) -> List[PreviewVersion]:
        return await self.db_connector.query(
            "SELECT * FROM preview_versions WHERE request_id = %s AND phase = %s ORDER BY created_at DESC",
            [request_id, phase]
        )
```

### 3.4 HITLフィードバックシステム設計

#### 3.4.1 チャットベースフィードバックハンドラー

```python
class HITLFeedbackHandler:
    """
    自然言語フィードバック処理システム
    """
    def __init__(self):
        self.nlp_processor = GeminiNLPProcessor()
        self.feedback_parser = FeedbackParser()
        self.timeout_manager = TimeoutManager()
        
    async def wait_for_feedback(self, request_id: str, phase: int, timeout: int = 1800) -> dict:
        """
        フィードバック待機（最大30分）
        """
        # WebSocket通知送信
        await self.notify_feedback_waiting(request_id, phase)
        
        # タイムアウト設定
        async with self.timeout_manager.timeout(timeout):
            try:
                # Redis経由でフィードバック待機
                feedback = await self.redis_client.brpop(
                    f"feedback:{request_id}:{phase}",
                    timeout=timeout
                )
                
                if feedback:
                    # 自然言語処理
                    parsed = await self.nlp_processor.parse_feedback(feedback)
                    return {
                        'raw_feedback': feedback,
                        'parsed_instructions': parsed,
                        'phase': phase,
                        'timestamp': time.time()
                    }
            except asyncio.TimeoutError:
                # タイムアウト時は自動スキップ
                return None
                
        return None
    
    async def apply_natural_language_feedback(self, data: dict, feedback: str, phase: int) -> dict:
        """
        チャットからの自然言語フィードバックを適用
        """
        # Gemini Proで意図解析
        intent = await self.nlp_processor.analyze_intent(feedback)
        
        # フェーズ別処理
        processor = self.get_phase_processor(phase)
        
        # 修正内容を適用
        modified_data = await processor.apply_modifications(data, intent)
        
        return modified_data

class ChatInterface:
    """
    チャットインターフェース管理
    """
    def __init__(self):
        self.message_history = {}
        self.quick_actions = self.load_quick_actions()
        
    async def process_chat_message(self, request_id: str, phase: int, message: str) -> dict:
        """
        チャットメッセージ処理
        """
        # メッセージ履歴追加
        self.add_to_history(request_id, phase, message)
        
        # クイックアクション判定
        if self.is_quick_action(message):
            return await self.process_quick_action(message, phase)
        
        # 自然言語処理
        feedback = await self.process_natural_language(message, phase)
        
        return {
            'type': 'feedback',
            'phase': phase,
            'content': feedback,
            'quick_options': self.get_phase_quick_options(phase)
        }
    
    def get_phase_quick_options(self, phase: int) -> list:
        """
        フェーズ別クイックアクションボタン
        """
        options = {
            1: ["もっと明るく", "シリアスに", "ジャンル変更", "対象年齢変更"],
            2: ["キャラ追加", "キャラ削除", "性格変更", "ビジュアル調整"],
            3: ["ペーシング速く", "ペーシング遅く", "クライマックス変更", "展開追加"],
            4: ["コマ割り変更", "構図調整", "アングル変更", "演出強化"],
            5: ["画風変更", "色調整", "再生成", "品質向上"],
            6: ["セリフ位置変更", "フォント変更", "効果音追加", "吹き出し調整"],
            7: ["最終調整", "フォーマット変更", "品質設定", "出力確認"]
        }
        return options.get(phase, [])
```

#### 3.4.2 フェーズ別プレビューコンポーネント

```python
class PhasePreviewComponents:
    """
    各フェーズ専用プレビューコンポーネント
    """
    
    def get_phase1_preview(self, data: dict) -> dict:
        """Phase 1: コンセプトプレビュー"""
        return {
            'component': 'ConceptPreview',
            'data': {
                'theme': data.get('theme'),
                'genre': data.get('genre'),
                'world_setting': data.get('world_setting'),
                'target_audience': data.get('target_audience'),
                'mood_board': data.get('mood_images', [])
            },
            'interactive': {
                'genre_selector': True,
                'mood_slider': True,
                'audience_adjuster': True
            }
        }
    
    def get_phase2_preview(self, data: dict) -> dict:
        """Phase 2: キャラクタープレビュー"""
        return {
            'component': 'CharacterPreview',
            'data': {
                'characters': data.get('characters', []),
                'relationships': data.get('relationships'),
                'visual_designs': data.get('visual_designs', [])
            },
            'interactive': {
                'character_editor': True,
                'relationship_map': True,
                'visual_adjuster': True
            }
        }
    
    def get_phase3_preview(self, data: dict) -> dict:
        """Phase 3: プロットプレビュー"""
        return {
            'component': 'PlotPreview',
            'data': {
                'three_act_structure': data.get('three_act_structure'),
                'emotional_arc': data.get('emotional_arc'),
                'scene_timeline': data.get('scene_timeline')
            },
            'interactive': {
                'timeline_editor': True,
                'emotion_curve': True,
                'pacing_adjuster': True
            }
        }
    
    def get_phase4_preview(self, data: dict) -> dict:
        """Phase 4: ネームプレビュー"""
        return {
            'component': 'NamePreview',
            'data': {
                'panel_layouts': data.get('panel_layouts'),
                'scene_directions': data.get('scene_directions'),
                'camera_angles': data.get('camera_angles')
            },
            'interactive': {
                'panel_grid': True,
                'composition_selector': True,
                'angle_adjuster': True
            }
        }
    
    def get_phase5_preview(self, data: dict) -> dict:
        """Phase 5: 画像プレビュー"""
        return {
            'component': 'SceneImagePreview',
            'data': {
                'generated_images': data.get('generated_images', []),
                'style_consistency': data.get('style_consistency'),
                'quality_metrics': data.get('quality_metrics')
            },
            'interactive': {
                'style_selector': True,
                'color_adjuster': True,
                'regenerate_button': True
            }
        }
    
    def get_phase6_preview(self, data: dict) -> dict:
        """Phase 6: セリフプレビュー"""
        return {
            'component': 'DialogPreview',
            'data': {
                'dialog_bubbles': data.get('dialog_bubbles'),
                'font_styles': data.get('font_styles'),
                'sound_effects': data.get('sound_effects')
            },
            'interactive': {
                'drag_drop': True,
                'font_selector': True,
                'effect_editor': True
            }
        }
    
    def get_phase7_preview(self, data: dict) -> dict:
        """Phase 7: 最終プレビュー"""
        return {
            'component': 'FinalPreview',
            'data': {
                'complete_pages': data.get('complete_pages'),
                'quality_report': data.get('quality_report'),
                'export_options': data.get('export_options')
            },
            'interactive': {
                'page_viewer': True,
                'quality_selector': True,
                'export_settings': True
            }
        }
```

### 3.5 データフロー

```mermaid
sequenceDiagram
    participant U as User
    participant G as API Gateway
    participant MS as Manga Service
    participant M1 as Module1-8
    participant R as Redis
    participant S as Storage
    participant AI as Google AI APIs
    
    U->>G: Submit Request
    G->>MS: Start Processing
    MS->>M1: Execute Pipeline
    
    loop For each module
        M1->>M1: Process Data (In-Memory)
        M1->>AI: Call External API
        AI-->>M1: Return Result
        M1->>R: Save Checkpoint (Async)
    end
    
    MS->>S: Save Final Output
    MS->>U: Return Result
```

---

## 4. インフラストラクチャ設計

### 4.1 Cloud Run構成

#### 3.1.1 デプロイメント設定

```yaml
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: manga-generation-service
spec:
  template:
    metadata:
      annotations:
        run.googleapis.com/cpu: "8"
        run.googleapis.com/memory: "32Gi"
        run.googleapis.com/execution-environment: gen2
        run.googleapis.com/cpu-boost: "true"
        run.googleapis.com/vpc-access-egress: all-traffic
    spec:
      containerConcurrency: 50
      timeoutSeconds: 600
      serviceAccountName: manga-service-account
      containers:
      - image: gcr.io/PROJECT_ID/manga-generation:latest
        resources:
          limits:
            cpu: "8"
            memory: "32Gi"
        env:
        - name: REDIS_HOST
          value: "redis-instance-endpoint"
        - name: GEMINI_API_KEY
          valueFrom:
            secretKeyRef:
              name: gemini-api-key
              key: key
        - name: IMAGEN_API_KEY
          valueFrom:
            secretKeyRef:
              name: imagen-api-key
              key: key
```

#### 3.1.2 オートスケーリング設定

| 項目 | 設定値 | 説明 |
|------|--------|------|
| 最小インスタンス | 1 | コールドスタート対策 |
| 最大インスタンス | 50 | ピーク時対応 |
| 同時リクエスト | 50 | メモリ使用量を考慮 |
| CPU使用率閾値 | 80% | スケールアウトトリガー |
| メモリ使用率閾値 | 70% | スケールアウトトリガー |
| スケールダウン遅延 | 300秒 | 頻繁なスケーリング防止 |

### 4.2 ストレージ設計

#### 3.2.1 Cloud Storage バケット構成

| バケット名 | 用途 | ストレージクラス | ライフサイクル |
|-----------|------|-----------------|---------------|
| manga-input-data | 入力テキスト | Standard | 30日後にNearline |
| manga-output-images | 生成画像 | Standard | CDN配信 |
| manga-final-products | 完成作品 | Standard | 90日後にColdline |
| manga-temp-data | 一時ファイル | Standard | 7日後に削除 |

#### 3.2.2 CDN設定

```yaml
CDN Configuration:
  Origin: manga-output-images.storage.googleapis.com
  Cache TTL: 86400 (1 day)
  Compression: Enabled (gzip, brotli)
  Geographic Distribution: Global
  SSL: Enabled
  Custom Domain: cdn.manga-service.com
```

### 4.3 Redis単一インスタンス設計

#### 3.3.1 インスタンス構成

```yaml
Redis Single Instance Configuration:
  Version: 7.0
  Instance Type: Basic (Memory Store for Redis)
  Memory: 4GB
  Persistence: RDB snapshot
  Network: Private VPC
  Backup: Daily snapshot to Cloud Storage
  Cost: ~$120/month
```

#### 3.3.2 データ構造設計

```redis
# Request Data
KEY: request:{request_id}:metadata
TYPE: Hash
TTL: 86400 (24 hours)
FIELDS:
  - status: processing|completed|failed
  - module: 1-8
  - created_at: timestamp
  - updated_at: timestamp

# Module Checkpoint Data
KEY: request:{request_id}:module{n}:checkpoint
TYPE: JSON
TTL: 86400 (24 hours)

# API Rate Limiting
KEY: api:rate_limit:{api_name}:{date}
TYPE: String (counter)
TTL: 86400 (24 hours)
```

---

## 5. 外部API統合設計

### 5.1 Google AI API接続

#### 4.1.1 API Client設定

```python
class GoogleAIClient:
    def __init__(self):
        self.gemini_client = gemini.Client(
            api_key=os.environ['GEMINI_API_KEY'],
            timeout=30,
            max_retries=3
        )
        self.imagen_client = imagen.Client(
            api_key=os.environ['IMAGEN_API_KEY'],
            timeout=60,
            max_retries=3
        )
    
    async def call_with_rate_limit(self, api_name, request):
        # Check rate limit in Redis
        current_count = await redis.incr(f"api:rate_limit:{api_name}:{today}")
        if current_count > MAX_DAILY_LIMIT:
            raise RateLimitExceeded()
        
        # Execute API call
        return await self._execute_api_call(api_name, request)
```

#### 4.1.2 API使用量配分

| フェーズ | API | 1リクエストあたり呼び出し回数 | 日次上限配分 |
|---------|-----|------------------------------|-------------|
| Phase 1 | Gemini Pro | 1 | 1,000 |
| Phase 2 | Gemini Pro | 1 | 1,000 |
| Phase 3 | Gemini Pro | 1 | 1,000 |
| Phase 4 | Gemini Pro | 2 | 2,000 |
| Phase 5 | Gemini Pro | 1 | 1,000 |
| Phase 6 | Imagen 4 | 10-50 | 3,000 |
| Phase 7 | Gemini Pro | 1 | 1,000 |

### 5.2 レート制限管理

#### 4.2.1 Redis カウンター実装

```python
class RateLimitManager:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.limits = {
            'gemini_pro': 7000,  # 70% of 10,000
            'imagen_4': 3000     # 30% of 10,000
        }
    
    async def check_and_increment(self, api_name):
        key = f"api:rate_limit:{api_name}:{datetime.now().date()}"
        
        # Atomic increment
        current = await self.redis.incr(key)
        
        # Set expiry on first increment
        if current == 1:
            await self.redis.expire(key, 86400)
        
        # Check limit
        if current > self.limits.get(api_name, 10000):
            raise RateLimitExceeded(f"{api_name} daily limit reached")
        
        return current
```

---

## 6. 信頼性設計

### 6.1 エラーハンドリング

#### 5.1.1 エラー分類と対処

| エラー種別 | HTTPステータス | リトライ可否 | 対処方法 |
|-----------|--------------|------------|----------|
| API Rate Limit | 429 | No | キューに戻して翌日処理 |
| API Timeout | 504 | Yes | 指数バックオフでリトライ |
| Invalid Input | 400 | No | ユーザーに通知 |
| Service Error | 500 | Yes | 自動リトライ（最大3回） |
| Resource Exhausted | 503 | Yes | 5分後にリトライ |

#### 5.1.2 エラー処理フロー

```python
class ErrorHandler:
    def __init__(self):
        self.max_retries = 3
        self.base_delay = 1  # seconds
    
    async def handle_error(self, error, context):
        error_type = self.classify_error(error)
        
        if error_type == 'rate_limit':
            await self.queue_for_tomorrow(context)
        elif error_type == 'retryable':
            await self.retry_with_backoff(context)
        else:
            await self.notify_failure(context)
    
    async def retry_with_backoff(self, context):
        retry_count = context.get('retry_count', 0)
        if retry_count >= self.max_retries:
            return await self.notify_failure(context)
        
        delay = self.base_delay * (2 ** retry_count)
        await asyncio.sleep(delay)
        
        # Retry module execution
        await self.retry_module_execution(context, retry_count + 1)
```

### 6.2 リトライ戦略

#### 5.2.1 指数バックオフ実装

```python
def exponential_backoff(retry_count, base_delay=1, max_delay=60):
    """
    Calculate delay with jitter
    """
    delay = min(base_delay * (2 ** retry_count), max_delay)
    jitter = random.uniform(0, delay * 0.1)
    return delay + jitter
```

#### 5.2.2 フェーズ別リトライ設定

| フェーズ | 最大リトライ | 初期遅延 | 最大遅延 |
|---------|------------|---------|---------|
| Phase 1-5 | 3 | 1秒 | 30秒 |
| Phase 6 | 3 | 5秒 | 60秒 |
| Phase 7 | 3 | 1秒 | 30秒 |


---

## 7. セキュリティ設計

### 7.1 認証・認可

| コンポーネント | 認証方式 | 認可方式 |
|---------------|---------|---------|
| Client → API Gateway | JWT Token | RBAC |
| API Gateway → Services | Service Account | IAM |
| Services → External API | API Key | -  |
| Services → Redis | Password | ACL |
| Services → Storage | Service Account | IAM |

### 7.2 データ保護

| データ種別 | 保存時暗号化 | 転送時暗号化 | アクセス制御 |
|-----------|------------|------------|------------|
| ユーザーデータ | AES-256 | TLS 1.3 | IAM + ACL |
| 生成画像 | AES-256 | TLS 1.3 | Signed URL |
| API Key | Secret Manager | TLS 1.3 | Service Account |
| ログ | AES-256 | TLS 1.3 | IAM |

### 7.3 ネットワークセキュリティ

```yaml
VPC Configuration:
  Name: manga-service-vpc
  CIDR: 10.0.0.0/16
  
  Subnets:
    - Cloud Run: 10.0.1.0/24
    - Redis: 10.0.2.0/24
    - Database: 10.0.3.0/24
  
  Firewall Rules:
    - Allow HTTPS from Internet to Load Balancer
    - Allow internal communication within VPC
    - Deny all other inbound traffic
  
  Private Service Connect:
    - Google APIs access without public IP
```

---

## 8. パフォーマンス設計

### 8.1 処理時間目標

| 処理内容 | 目標時間 | 最大時間 |
|---------|---------|---------|
| 5,000文字処理 | 8分 | 10分 |
| 10,000文字処理 | 9分 | 10分 |
| 50,000文字処理 | 10分 | 12分 |

### 8.2 スケーラビリティ指標

| メトリクス | 目標値 | 対策 |
|-----------|--------|------|
| 同時処理数 | 100 | Cloud Run自動スケーリング |
| スループット | 500req/hour | 並列処理最適化 |
| レスポンス時間 | <100ms (API) | CDN、Redis Cache |

### 8.3 最適化戦略

```python
# バッチ処理による最適化
class BatchProcessor:
    def __init__(self, batch_size=10):
        self.batch_size = batch_size
        self.queue = []
    
    async def process_batch(self, items):
        """
        Process multiple items in a single API call
        """
        if len(items) >= self.batch_size:
            batch = items[:self.batch_size]
            results = await self.api_client.batch_call(batch)
            return results
```

---


---

## 改訂履歴

| 版数 | 日付 | 変更内容 | 担当者 |
|------|------|----------|--------|
| 1.0 | 2025-01-20 | 初版作成 | Claude Code |
| 3.0 | 2025-08-28 | Backend_Implementation_Guide.md統合・実装詳細仕様追加 | Claude Code |

---

**文書承認**
- システムアーキテクト: [署名] 日付: [日付]
- インフラエンジニア: [署名] 日付: [日付]
- セキュリティ責任者: [署名] 日付: [日付]