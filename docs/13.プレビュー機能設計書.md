# プレビュー機能設計書

**文書管理情報**
- 文書ID: PREVIEW-DOC-001
- 作成日: 2025-01-27
- 版数: 1.0
- 承認者: [承認者名]

## 目次

- [1. プレビュー機能概要](#1-プレビュー機能概要)
- [2. フェーズ特化型データ構造](#2-フェーズ特化型データ構造)
- [3. フル・インタラクティブ機能](#3-フル・インタラクティブ機能)
- [4. アダプティブ品質システム](#4-アダプティブ品質システム)
- [5. プレビュー履歴・比較機能](#5-プレビュー履歴・比較機能)
- [6. キャッシュ・パフォーマンス戦略](#6-キャッシュ・パフォーマンス戦略)
- [7. API仕様](#7-api仕様)
- [8. 技術実装詳細](#8-技術実装詳細)

---

## 1. プレビュー機能概要

### 設計方針
- **フェーズ特化型**: 各フェーズの特性に最適化された専用データ構造
- **フル・インタラクティブ**: 全プレビュー要素がリアルタイム編集可能
- **アダプティブ品質**: ユーザー環境に応じた最適な品質提供
- **履歴・比較機能**: ブランチ型バージョン管理
- **CDN最適化**: Cloud CDNによる高速配信（Redis非依存）

## 2. フェーズ特化型データ構造

### Phase 1: コンセプト・世界観分析
```typescript
interface Phase1PreviewData {
  phase: 1;
  timestamp: string;
  version: number;
  
  concept: {
    title: string;
    summary: string;
    tagline: string;
    keywords: string[];
  };
  
  genre: {
    primary: string;
    secondary?: string;
    subgenres: string[];
    style_influences: string[];
  };
  
  target_audience: {
    age_group: string;
    gender_focus: string;
    interests: string[];
    reading_habits: string[];
  };
  
  world_setting: {
    era: string;
    location: string;
    social_context: string;
    key_elements: string[];
    visual_motifs: string[];
  };
  
  tone: {
    mood: string;
    atmosphere: string;
    emotional_range: string[];
    visual_style_hints: string[];
  };
  
  interactive_elements: {
    concept_editor: boolean;
    genre_selector: boolean;
    audience_adjuster: boolean;
    tone_slider: boolean;
  };
}
```

### Phase 2: キャラクター設定・簡易ビジュアル
```typescript
interface Phase2PreviewData {
  phase: 2;
  timestamp: string;
  version: number;
  
  characters: Character[];
  
  interactive_elements: {
    character_editor: boolean;
    visual_style_picker: boolean;
    relationship_graph_editor: boolean;
    appearance_customizer: boolean;
  };
}

interface Character {
  id: string;
  name: string;
  role: "protagonist" | "antagonist" | "supporting" | "background";
  
  demographics: {
    age: number;
    gender: string;
    personality_traits: string[];
  };
  
  visual_reference: {
    primary_image: {
      url: string;
      thumbnail_url: string;
      alt_text: string;
    };
    variations?: {
      expressions: ImageVariation[];
      outfits: ImageVariation[];
      poses: ImageVariation[];
    };
  };
  
  relationships: {
    character_id: string;
    relationship_type: string;
    strength: number; // 0-1
    description: string;
  }[];
  
  character_arc: {
    starting_point: string;
    development: string;
    ending_point: string;
  };
  
  interactive_features: {
    appearance_editable: boolean;
    name_editable: boolean;
    personality_editable: boolean;
    relationship_editable: boolean;
  };
}
```

### Phase 3: プロット・ストーリー構成
```typescript
interface Phase3PreviewData {
  phase: 3;
  timestamp: string;
  version: number;
  
  story_structure: {
    acts: Act[];
    pacing: PacingData;
    emotional_arc: EmotionalPoint[];
  };
  
  scenes: Scene[];
  
  interactive_elements: {
    scene_reorder: boolean;
    pacing_adjuster: boolean;
    emotional_curve_editor: boolean;
    conflict_intensity_slider: boolean;
  };
}

interface Act {
  number: number;
  title: string;
  description: string;
  scenes: string[]; // scene IDs
  key_events: string[];
  emotional_tone: string;
  duration_pages: number;
}

interface Scene {
  id: string;
  title: string;
  description: string;
  characters_present: string[];
  location: string;
  time_of_day: string;
  emotional_intensity: number; // 0-1
  conflict_level: number; // 0-1
  page_estimate: number;
  
  interactive_features: {
    editable_description: boolean;
    character_placement: boolean;
    intensity_slider: boolean;
  };
}
```

### Phase 4: ネーム生成
```typescript
interface Phase4PreviewData {
  phase: 4;
  timestamp: string;
  version: number;
  
  pages: Page[];
  
  interactive_elements: {
    panel_editor: boolean;
    layout_templates: boolean;
    reading_flow_optimizer: boolean;
    speech_bubble_placer: boolean;
  };
}

interface Page {
  number: number;
  panels: Panel[];
  layout_type: string;
  reading_flow_score: number;
  
  interactive_features: {
    panel_resizable: boolean;
    panel_draggable: boolean;
    layout_changeable: boolean;
  };
}

interface Panel {
  id: string;
  position: { x: number; y: number; width: number; height: number };
  scene_id: string;
  camera_angle: CameraAngle;
  characters: CharacterPlacement[];
  background: BackgroundInfo;
  effects: VisualEffect[];
  
  interactive_features: {
    resizable: boolean;
    draggable: boolean;
    camera_adjustable: boolean;
    character_movable: boolean;
  };
}
```

### Phase 5: シーン画像生成
```typescript
interface Phase5PreviewData {
  phase: 5;
  timestamp: string;
  version: number;
  
  generated_images: GeneratedImage[];
  
  interactive_elements: {
    image_selector: boolean;
    style_adjuster: boolean;
    quality_enhancer: boolean;
    regeneration_trigger: boolean;
  };
}

interface GeneratedImage {
  panel_id: string;
  variations: ImageVariation[];
  selected_variation: number;
  generation_metadata: {
    prompt_used: string;
    style_parameters: StyleParams;
    generation_time: number;
    quality_score: number;
  };
  
  interactive_features: {
    variation_selector: boolean;
    style_tweaker: boolean;
    regenerate_button: boolean;
    quality_booster: boolean;
  };
}
```

### Phase 6: セリフ配置
```typescript
interface Phase6PreviewData {
  phase: 6;
  timestamp: string;
  version: number;
  
  pages: PageWithText[];
  
  interactive_elements: {
    speech_bubble_editor: boolean;
    text_style_picker: boolean;
    bubble_position_adjuster: boolean;
    sound_effect_placer: boolean;
  };
}

interface PageWithText {
  page_number: number;
  panels: PanelWithText[];
  
  interactive_features: {
    text_editable: boolean;
    bubble_movable: boolean;
    font_changeable: boolean;
  };
}

interface PanelWithText {
  panel_id: string;
  speech_bubbles: SpeechBubble[];
  sound_effects: SoundEffect[];
  narration_boxes: NarrationBox[];
}
```

### Phase 7: 最終統合・品質調整
```typescript
interface Phase7PreviewData {
  phase: 7;
  timestamp: string;
  version: number;
  
  final_manga: {
    pages: FinalPage[];
    formats: OutputFormat[];
    quality_report: QualityReport;
  };
  
  interactive_elements: {
    page_navigator: boolean;
    zoom_controller: boolean;
    format_selector: boolean;
    quality_adjuster: boolean;
  };
}
```

## 3. フル・インタラクティブ機能

### インタラクション機能マトリクス

| フェーズ | 編集可能要素 | インタラクション種別 | リアルタイム反映 |
|---------|-------------|-------------------|-----------------|
| Phase 1 | コンセプト、ジャンル、対象読者 | テキスト編集、選択 | ✅ |
| Phase 2 | キャラ名、外見、関係性 | 画像選択、テキスト編集 | ✅ |
| Phase 3 | シーン順序、感情曲線 | ドラッグ&ドロップ、スライダー | ✅ |
| Phase 4 | コマサイズ、配置、レイアウト | リサイズ、ドラッグ&ドロップ | ✅ |
| Phase 5 | 画像選択、スタイル調整 | 画像選択、パラメータ調整 | ✅ |
| Phase 6 | セリフ、吹き出し位置 | テキスト編集、ドラッグ&ドロップ | ✅ |
| Phase 7 | ページ順序、出力設定 | 並び替え、設定変更 | ✅ |

### インタラクション実装

```typescript
class InteractivePreviewEngine {
  private websocket: WebSocket;
  private debounceTimer: NodeJS.Timeout;
  
  // リアルタイム編集機能
  enableRealtimeEditing(element: HTMLElement, type: InteractionType) {
    switch(type) {
      case 'text_edit':
        this.setupTextEditor(element);
        break;
      case 'drag_drop':
        this.setupDragDrop(element);
        break;
      case 'resize':
        this.setupResize(element);
        break;
      case 'selection':
        this.setupSelection(element);
        break;
    }
  }
  
  // 変更の即座反映
  private async handleChange(elementId: string, changeData: any) {
    // デバウンス処理
    clearTimeout(this.debounceTimer);
    this.debounceTimer = setTimeout(async () => {
      // WebSocketで即座にバックエンドに送信
      await this.sendChange(elementId, changeData);
    }, 300);
  }
  
  private async sendChange(elementId: string, changeData: any) {
    this.websocket.send(JSON.stringify({
      type: 'preview_change',
      element_id: elementId,
      change_data: changeData,
      timestamp: Date.now()
    }));
  }
}
```

## 4. アダプティブ品質システム

### 品質レベル定義

```typescript
enum QualityLevel {
  ULTRA_LOW = 1,   // 超低品質：テキストのみ、プレースホルダー画像
  LOW = 2,         // 低品質：低解像度画像、基本スタイリング
  MEDIUM = 3,      // 中品質：標準解像度、部分インタラクション
  HIGH = 4,        // 高品質：高解像度、フルインタラクション
  ULTRA_HIGH = 5   // 超高品質：最高解像度、全機能有効
}

class AdaptiveQualityManager {
  private deviceCapability: number;
  private networkSpeed: number;
  private userPreference: QualityLevel;
  
  constructor() {
    this.deviceCapability = this.detectDeviceCapability();
    this.networkSpeed = this.detectNetworkSpeed();
    this.userPreference = this.getUserPreference();
  }
  
  determineOptimalQuality(phaseData: any): QualityLevel {
    const deviceScore = this.deviceCapability;
    const networkScore = this.networkSpeed / 10000; // Normalize
    const contentComplexity = this.calculateComplexity(phaseData);
    
    const baseScore = (deviceScore + networkScore) / 2;
    const adjustedScore = baseScore * (1 - contentComplexity * 0.3);
    
    if (adjustedScore >= 0.8) return QualityLevel.ULTRA_HIGH;
    if (adjustedScore >= 0.6) return QualityLevel.HIGH;
    if (adjustedScore >= 0.4) return QualityLevel.MEDIUM;
    if (adjustedScore >= 0.2) return QualityLevel.LOW;
    return QualityLevel.ULTRA_LOW;
  }
  
  private detectDeviceCapability(): number {
    const memory = (navigator as any).deviceMemory || 4;
    const cores = navigator.hardwareConcurrency || 2;
    const pixelRatio = window.devicePixelRatio || 1;
    
    // 正規化スコア (0-1)
    return Math.min(1, (memory / 8 + cores / 8 + pixelRatio / 3) / 3);
  }
  
  private detectNetworkSpeed(): number {
    const connection = (navigator as any).connection;
    if (!connection) return 5000; // デフォルト5Mbps
    
    return connection.effectiveType === '4g' ? 10000 :
           connection.effectiveType === '3g' ? 1500 :
           connection.effectiveType === '2g' ? 500 : 5000;
  }
}
```

### 品質別レンダリング戦略

```typescript
class QualityRenderer {
  async renderPreview(data: PreviewData, quality: QualityLevel): Promise<RenderedPreview> {
    switch(quality) {
      case QualityLevel.ULTRA_LOW:
        return this.renderTextOnly(data);
        
      case QualityLevel.LOW:
        return this.renderLowQuality(data);
        
      case QualityLevel.MEDIUM:
        return this.renderMediumQuality(data);
        
      case QualityLevel.HIGH:
        return this.renderHighQuality(data);
        
      case QualityLevel.ULTRA_HIGH:
        return this.renderUltraHighQuality(data);
    }
  }
  
  private async renderTextOnly(data: PreviewData): Promise<RenderedPreview> {
    return {
      content: this.generateTextSummary(data),
      images: [], // 画像なし
      interactivity: false,
      loadTime: '< 1s'
    };
  }
  
  private async renderUltraHighQuality(data: PreviewData): Promise<RenderedPreview> {
    return {
      content: await this.generateFullContent(data),
      images: await this.generateHighResImages(data),
      interactivity: true,
      animations: true,
      loadTime: '3-5s'
    };
  }
}
```

## 5. プレビュー履歴・比較機能

### ブランチ型バージョン管理

```typescript
interface PreviewBranch {
  id: string;
  parentId?: string;
  phase: number;
  timestamp: Date;
  data: PreviewData;
  
  metadata: {
    changeDescription: string;
    userFeedback?: string;
    qualityScore: number;
    automaticChange: boolean;
  };
  
  children: string[]; // child branch IDs
}

class PreviewVersionManager {
  private branches: Map<string, PreviewBranch> = new Map();
  private currentBranch: string;
  
  createBranch(parentId: string, data: PreviewData, description: string): string {
    const branchId = this.generateBranchId();
    const parent = this.branches.get(parentId);
    
    const branch: PreviewBranch = {
      id: branchId,
      parentId: parentId,
      phase: data.phase,
      timestamp: new Date(),
      data: data,
      metadata: {
        changeDescription: description,
        qualityScore: this.calculateQuality(data),
        automaticChange: false
      },
      children: []
    };
    
    if (parent) {
      parent.children.push(branchId);
    }
    
    this.branches.set(branchId, branch);
    this.currentBranch = branchId;
    
    return branchId;
  }
  
  compareVersions(branch1Id: string, branch2Id: string): ComparisonResult {
    const branch1 = this.branches.get(branch1Id);
    const branch2 = this.branches.get(branch2Id);
    
    if (!branch1 || !branch2) {
      throw new Error('Branch not found');
    }
    
    return {
      differences: this.calculateDifferences(branch1.data, branch2.data),
      qualityComparison: {
        branch1: branch1.metadata.qualityScore,
        branch2: branch2.metadata.qualityScore,
        improvement: branch2.metadata.qualityScore - branch1.metadata.qualityScore
      },
      visualDiff: this.generateVisualDiff(branch1.data, branch2.data)
    };
  }
  
  revertToBranch(branchId: string): void {
    if (!this.branches.has(branchId)) {
      throw new Error('Branch not found');
    }
    
    this.currentBranch = branchId;
    
    // UI更新通知
    this.notifyBranchChange(branchId);
  }
  
  getBranchHistory(): BranchHistoryView {
    const currentBranch = this.branches.get(this.currentBranch);
    const history: PreviewBranch[] = [];
    
    // 現在のブランチから親を辿る
    let current = currentBranch;
    while (current) {
      history.unshift(current);
      current = current.parentId ? this.branches.get(current.parentId) : undefined;
    }
    
    return {
      timeline: history,
      branches: this.getAllBranches(),
      currentBranchId: this.currentBranch
    };
  }
}
```

### 比較機能UI

```typescript
class PreviewComparisonUI {
  renderComparison(comparison: ComparisonResult): HTMLElement {
    const container = document.createElement('div');
    container.className = 'preview-comparison';
    
    // サイドバイサイド比較
    const sideBySide = this.createSideBySideView(comparison);
    
    // オーバーレイ比較
    const overlay = this.createOverlayView(comparison);
    
    // 差分ハイライト
    const diffHighlight = this.createDiffHighlight(comparison);
    
    // タブ切り替え
    const tabs = this.createComparisonTabs([
      { label: 'サイドバイサイド', content: sideBySide },
      { label: 'オーバーレイ', content: overlay },
      { label: '差分ハイライト', content: diffHighlight }
    ]);
    
    container.appendChild(tabs);
    
    return container;
  }
  
  private createSideBySideView(comparison: ComparisonResult): HTMLElement {
    const container = document.createElement('div');
    container.className = 'side-by-side-comparison';
    
    // 左側: Before
    const before = document.createElement('div');
    before.className = 'comparison-before';
    before.innerHTML = this.renderPreviewData(comparison.before);
    
    // 右側: After
    const after = document.createElement('div');
    after.className = 'comparison-after';
    after.innerHTML = this.renderPreviewData(comparison.after);
    
    container.appendChild(before);
    container.appendChild(after);
    
    return container;
  }
}
```

## 6. キャッシュ・パフォーマンス戦略

### CDN最適化戦略

```typescript
class CDNOptimizedCacheStrategy {
  private cdnBaseUrl: string;
  private cacheHeaders: CacheHeaders;
  
  constructor(cdnBaseUrl: string) {
    this.cdnBaseUrl = cdnBaseUrl;
    this.cacheHeaders = this.setupCacheHeaders();
  }
  
  private setupCacheHeaders(): CacheHeaders {
    return {
      // 静的画像ファイル
      images: {
        'Cache-Control': 'public, max-age=604800, immutable', // 7日
        'CDN-Cache-Control': 'public, max-age=2592000' // CDNで30日
      },
      
      // プレビューメタデータ
      metadata: {
        'Cache-Control': 'public, max-age=1800', // 30分
        'CDN-Cache-Control': 'public, max-age=3600' // CDNで1時間
      },
      
      // インタラクティブアセット
      interactive: {
        'Cache-Control': 'public, max-age=86400', // 1日
        'CDN-Cache-Control': 'public, max-age=604800' // CDNで7日
      }
    };
  }
  
  async cachePreviewData(phase: number, data: PreviewData): Promise<string> {
    const cacheKey = this.generateCacheKey(phase, data);
    
    // CDNにアップロード
    const cdnUrl = await this.uploadToCDN(cacheKey, data);
    
    // ブラウザキャッシュ設定
    this.setBrowserCache(cdnUrl, this.cacheHeaders.metadata);
    
    return cdnUrl;
  }
  
  private async uploadToCDN(key: string, data: PreviewData): Promise<string> {
    const response = await fetch(`${this.cdnBaseUrl}/upload`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...this.cacheHeaders.metadata
      },
      body: JSON.stringify(data)
    });
    
    const result = await response.json();
    return result.url;
  }
  
  async getFromCache(phase: number, dataHash: string): Promise<PreviewData | null> {
    const cacheKey = `preview-${phase}-${dataHash}`;
    const cdnUrl = `${this.cdnBaseUrl}/${cacheKey}`;
    
    try {
      const response = await fetch(cdnUrl);
      if (response.ok) {
        return await response.json();
      }
    } catch (error) {
      console.warn('Cache miss:', error);
    }
    
    return null;
  }
  
  // 事前キャッシング
  async preloadNextPhases(currentPhase: number, userData: UserData): Promise<void> {
    const predictedPhases = this.predictNextPhases(currentPhase, userData);
    
    const preloadPromises = predictedPhases.map(async (phase) => {
      const estimatedData = this.estimatePhaseData(phase, userData);
      await this.cachePreviewData(phase, estimatedData);
    });
    
    await Promise.all(preloadPromises);
  }
}
```

### パフォーマンス最適化

```typescript
class PerformanceOptimizer {
  private observer: IntersectionObserver;
  private loadQueue: PreviewLoadTask[] = [];
  
  constructor() {
    this.setupLazyLoading();
    this.setupVirtualization();
  }
  
  private setupLazyLoading(): void {
    this.observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            this.loadPreviewElement(entry.target as HTMLElement);
          }
        });
      },
      { threshold: 0.1 }
    );
  }
  
  // 仮想スクロール（大量のプレビュー用）
  private setupVirtualization(): void {
    // Virtual scrolling for large preview lists
  }
  
  // 段階的ロード
  async loadPreviewProgressively(element: HTMLElement, data: PreviewData): Promise<void> {
    // Stage 1: 骨格表示 (100ms)
    const skeleton = this.createSkeleton(data);
    element.appendChild(skeleton);
    
    // Stage 2: 基本コンテンツ (500ms)
    await this.delay(100);
    const basicContent = await this.loadBasicContent(data);
    element.replaceChild(basicContent, skeleton);
    
    // Stage 3: 高品質コンテンツ (2000ms)
    await this.delay(400);
    const highQualityContent = await this.loadHighQualityContent(data);
    element.replaceChild(highQualityContent, basicContent);
  }
}
```

## 7. API仕様

### プレビュー関連エンドポイント

```typescript
// フェーズ別プレビュー取得
GET /api/v1/manga/{request_id}/preview/{phase}?quality={quality_level}

// インタラクティブ変更適用
POST /api/v1/manga/{request_id}/preview/{phase}/apply-change
{
  "element_id": "string",
  "change_type": "text_edit" | "position" | "style" | "selection",
  "change_data": any,
  "apply_immediately": boolean
}

// プレビュー履歴取得
GET /api/v1/manga/{request_id}/preview/{phase}/history

// バージョン比較
GET /api/v1/manga/{request_id}/preview/compare?branch1={id}&branch2={id}

// プレビューキャッシュ
GET /api/v1/manga/preview/cache/{cache_key}
```

### WebSocket イベント

```typescript
// リアルタイム変更通知
interface PreviewChangeEvent {
  type: 'preview_change';
  phase: number;
  element_id: string;
  change_data: any;
  timestamp: number;
}

// プレビュー更新通知
interface PreviewUpdateEvent {
  type: 'preview_update';
  phase: number;
  preview_url: string;
  quality_level: QualityLevel;
  load_time: number;
}

// インタラクション状態通知
interface InteractionStateEvent {
  type: 'interaction_state';
  phase: number;
  available_interactions: InteractionType[];
  current_tool: string;
}
```

## 8. 技術実装詳細

### フロントエンド実装

```typescript
class UnifiedPreviewSystem {
  private adaptiveQuality: AdaptiveQualityManager;
  private versionManager: PreviewVersionManager;
  private cacheStrategy: CDNOptimizedCacheStrategy;
  private interactionEngine: InteractivePreviewEngine;
  
  async renderPhasePreview(phase: number, data: PreviewData): Promise<void> {
    // 1. 品質レベル決定
    const qualityLevel = this.adaptiveQuality.determineOptimalQuality(data);
    
    // 2. キャッシュチェック
    const cached = await this.cacheStrategy.getFromCache(phase, this.hashData(data));
    if (cached) {
      await this.renderCachedPreview(cached, qualityLevel);
      return;
    }
    
    // 3. 段階的レンダリング
    await this.renderProgressively(phase, data, qualityLevel);
    
    // 4. インタラクション有効化
    await this.interactionEngine.enableInteractions(phase, data);
    
    // 5. 履歴保存
    const branchId = this.versionManager.createBranch(
      this.versionManager.getCurrentBranch(),
      data,
      `Phase ${phase} render`
    );
    
    // 6. キャッシュ保存
    await this.cacheStrategy.cachePreviewData(phase, data);
  }
  
  private async renderProgressively(
    phase: number, 
    data: PreviewData, 
    quality: QualityLevel
  ): Promise<void> {
    const renderer = this.getPhaseRenderer(phase);
    
    // Stage 1: 即座表示
    const skeleton = await renderer.renderSkeleton(data);
    this.displayPreview(skeleton);
    
    // Stage 2: 基本品質
    if (quality >= QualityLevel.MEDIUM) {
      const basic = await renderer.renderBasic(data);
      this.updatePreview(basic);
    }
    
    // Stage 3: 高品質
    if (quality >= QualityLevel.HIGH) {
      const high = await renderer.renderHigh(data);
      this.updatePreview(high);
    }
  }
}
```

### バックエンド実装

```python
class PreviewService:
    def __init__(self):
        self.cdn_manager = CDNManager()
        self.quality_processor = QualityProcessor()
        self.version_store = VersionStore()
    
    async def generate_preview(
        self, 
        phase: int, 
        data: dict, 
        quality_level: QualityLevel
    ) -> PreviewData:
        
        # フェーズ特化型プロセッサを取得
        processor = self.get_phase_processor(phase)
        
        # 品質レベルに応じた処理
        processed_data = await self.quality_processor.process(
            data, quality_level
        )
        
        # プレビューデータ生成
        preview = await processor.generate_preview(processed_data)
        
        # CDNにアップロード
        cdn_urls = await self.cdn_manager.upload_preview_assets(preview)
        preview.update_urls(cdn_urls)
        
        # バージョン保存
        await self.version_store.save_version(phase, preview)
        
        return preview
    
    async def apply_interactive_change(
        self, 
        phase: int, 
        element_id: str, 
        change_data: dict
    ) -> PreviewData:
        
        # 現在のプレビューデータ取得
        current_preview = await self.get_current_preview(phase)
        
        # 変更適用
        updated_preview = await self.apply_change(
            current_preview, element_id, change_data
        )
        
        # 新しいブランチ作成
        branch_id = await self.version_store.create_branch(
            parent_id=current_preview.version_id,
            data=updated_preview,
            change_description=f"Interactive change: {element_id}"
        )
        
        # リアルタイム更新通知
        await self.notify_preview_update(phase, updated_preview)
        
        return updated_preview
```

---

**改訂履歴**

| 版数 | 日付 | 変更内容 | 作成者 |
|------|------|----------|--------|
| 1.0 | 2025-01-27 | 初版作成（フェーズ特化型構造、フル・インタラクティブ、アダプティブ品質、CDN最適化） | Claude Code |